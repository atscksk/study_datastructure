/*
알고리즘 복잡도

1. 알고리즘 복잡도 계산의 필요성
- 하나의 문제를 무는 알고리즘은 다양함
- 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산

2. 알고리즘 복잡도 계산 항목
1) 시간 복잡도 - 실행 속도(얼마나 빠르게 실행되는지)
2) 공간 복잡도 - 메모리 크기(얼마나 많은 저장 공간이 필요한지)

통상 둘 다를 만족시키기는 어려움
- 시간과 공간은 반비례적 경향이 있음
- 최근 대용량 시스템이 보편화되면서 공간 복잡도보다는 시간 복잡도가 우선
- 따라서 알고리즘은 시간 복잡도가 중심

3. 알고리즘 성능 표기법
1) Big-O(빅오) 표기법: O(N)
  - 알고리즘의 최악의 실행 시간 표기
  - 가장 많이, 일반적으로 사용됨
  - '최소 이 정도 성능을 보장함'의 의미
2) Ω(오메가) 표기법: Ω(N)
  - 알고리즘의 최상의 실행 시간 표기
3) Θ(세타) 표기법: Θ(N)
  - 알고리즘의 평균 실행 시간

4. 빅오(Big O) 표기법
1) O(n)
  - 입력 n에 따라 결정되는 시간 복잡도 함수
  - O(1), O(logn), O(n), O(nlogn), O(n^2), O(2^n), O(n!)등으로 표기
  - 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 증가할 수 있음
  - O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
2) 입력 n에 따라 몇 번 실행이 되는지를 계산
  - 표현식에 가장 큰 영향을 미치는 n의 단위로 표기
  - 상수는 무시, 차수가 높은 n으로 표시함
  - 예: 2^n + 3n => O(n^2)

5. 공간 복잡도
1)프로그램을 실행 및 완료하는데 필요한 저장공간의 양을 뜻함
2) 총 필요 저장 공간
- 고정 공간 (알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수
- 가변 공간 (알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간
𝑆(𝑃) = 𝑐 + 𝑆𝑝(𝑛) 
c: 고정 공간, 𝑆𝑝(𝑛) : 가변 공간
*/

// 예시: 1부터 n까지 합을 구하는 알고리즘
// 알고리즘1
function sumAll1(n) {
  var total = 0;
  for(var i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
var result1 = sumAll1(100);
console.log(result1);
/*
시간복잡도: 입력 n에 따라 덧셈을 n번 시행 => O(n)
*/

// 알고리즘2
function sumAll2(n) {
  return parseInt(n * (n + 1) / 2);
}
var result2 = sumAll2(100);
console.log(result2);
/*
시간복잡도
- 입력 n과 상관없이 곱셈/덧셈/나눗셈만 시행
- 반복문이 없음
- O(1)
*/